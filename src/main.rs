use std::ptr;

use esp_idf_sys::{xTaskCreatePinnedToCore};

use esp_idf_hal::delay::FreeRtos;
use esp_idf_hal::i2c::I2cError;
use esp_idf_hal::peripherals::Peripherals;
use esp_idf_sys::EspError;

use mpu6050::Mpu6050Error;

mod neopixel;
use neopixel::{get_color, get_error_rgbw8, get_logging_rgbw8, get_sleeping_rgbw8, NeoPixel};

mod mpu_6050;
use mpu_6050::{i2c_controller::I2cController, Mpu6050Controller, Mpu6050Data};

mod mqtt_client;
use mqtt_client::MqttClient;

mod wifi;
use wifi::WifiController;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    ssid: &'static str,
    #[default("")]
    password: &'static str,
    #[default("")]
    host: &'static str,
    #[default(1883)]
    port: u16,
    #[default("")]
    client_id: &'static str,
    #[default("")]
    username: &'static str,
    #[default("")]
    mqtt_password: &'static str,
}

pub struct TaskData<'a> {
    pub mpu: Mpu6050Controller<'a>,
    pub mqtt_client: MqttClient<'a>,
    pub neo_pixel: NeoPixel,
    pub topic: &'static str,
}

unsafe extern "C" fn task1(data: *mut core::ffi::c_void) {
    let task_data = data as *mut TaskData;
    let task_data = &mut *task_data;

    let mpu = &mut task_data.mpu;
    let mqtt_client = &mut task_data.mqtt_client;
    let neopixel = &mut task_data.neo_pixel;
    let topic = task_data.topic;

    loop {
        let logging_color = get_logging_rgbw8();
        neopixel.set_color(logging_color);

        let data = match get_data(mpu) {
            Ok(data) => data,
            Err(_) => {
                let error_color = get_error_rgbw8();
                neopixel.set_color(error_color);
                FreeRtos::delay_ms(1000);
                continue;
            }
        };

        let _res = match publish_data(mqtt_client, topic, data) {
            Ok(json) => {
                log::info!("Published data: {:?}", json);
                Ok(())
            }
            Err(e) => {
                log::error!("Failed to publish data: {:?}", e);
                Err(e)
            }
        };

        let sleeping_color = get_sleeping_rgbw8();
        neopixel.set_color(sleeping_color);

        FreeRtos::delay_ms(10000);
    }
}

pub fn get_data(mpu: &mut Mpu6050Controller) -> Result<Mpu6050Data, Mpu6050Error<I2cError>> {
    match mpu.get() {
        Ok(data) => {
            log::info!(
                "Acc: {:?} Gyro: {:?} Angles: {:?} Temp: {:?}",
                data.acceleration,
                data.rotation,
                data.angles,
                data.temperature
            );
            Ok(data)
        }
        Err(e) => {
            log::error!("Failed to get data: {:?}", e);
            Err(e)
        }
    }
}
pub fn get_json(data: Mpu6050Data) -> String {
    format!(
        r#"{{"acceleration": {:?}, "rotation": {:?}, "angles": {:?}, "temperature": {:?}}}"#,
        data.acceleration, data.rotation, data.angles, data.temperature
    )
}

pub fn publish_data(
    mqtt_client: &mut MqttClient,
    topic: &str,
    data: Mpu6050Data,
) -> Result<String, EspError> {
    let json = get_json(data);
    match mqtt_client.publish(topic, &json, 0) {
        Ok(_) => Ok(json),
        Err(e) => Err(e),
    }
}

fn main() {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    esp_idf_svc::log::EspLogger::initialize_default();
    esp_idf_svc::log::set_target_level("*", log::LevelFilter::Info).unwrap();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;
    if app_config.ssid == "" {
        panic!("You need to set the Wi-Fi credentials in `cfg.toml`!");
    } else {
        println!("Wi-Fi credentials are set in `cfg.toml`.");
    }

    let dp = Peripherals::take().unwrap();

    let neopixel_pin = dp.pins.gpio8;
    let rmt_channel = dp.rmt.channel0; // Use channel 0 for RMT
    let mut neopixel = NeoPixel::new(rmt_channel, neopixel_pin);
    neopixel.set_color(get_color(0, 0, 0, 0));

    let sda = dp.pins.gpio0;
    let scl = dp.pins.gpio1;
    let i2c = dp.i2c0;
    let baudrate = 100_u32;
    let i2c_controller = match I2cController::new(i2c, sda, scl, baudrate) {
        Ok(controller) => controller,
        Err(e) => {
            eprintln!("Failed to initialize I2C: {:?}", e);
            return;
        }
    };

    let mpu = match Mpu6050Controller::new(i2c_controller) {
        Ok(controller) => controller,
        Err(e) => {
            eprintln!("Failed to initialize MPU6050: {:?}", e);
            return;
        }
    };

    log::info!("ssid: {}", app_config.ssid.to_string());

    let wifi_client = match WifiController::new(app_config.ssid, app_config.password, dp.modem)
    {
        Ok(client) => client,
        Err(e) => {
            eprintln!("Failed to initialize WiFi controller: {:?}", e);
            return;
        }
    };

    while !wifi_client.is_connected() {
        log::info!("Waiting for Wi-Fi connection...");
        FreeRtos::delay_ms(1000);
    }

    log::info!("Wi-Fi connected");

    FreeRtos::delay_ms(5000);

    log::info!(
        "host: {} port: {}",
        app_config.host.to_string(),
        app_config.port
    );

    let mut mqtt_client = MqttClient::new(
        app_config.host,
        app_config.port,
        app_config.client_id,
        app_config.username,
        app_config.mqtt_password,
    )
    .expect("Failed to initialize MQTT client");

    let mut retry_count = 0;
    let max_retries = 5;
    while retry_count < max_retries {
        match mqtt_client.publish("test", "Hello World", 0) {
            Ok(_) => break,
            Err(e) => {
                eprintln!("Failed to publish message: {:?}", e);
                retry_count += 1;
                FreeRtos::delay_ms(1000);
            }
        }
    }

    let task_data = TaskData {
        mpu,
        mqtt_client,
        neo_pixel: neopixel,
        topic: "esp32/data/mpu6050/",
    };

    let task_data_ptr = Box::into_raw(Box::new(task_data)) as *mut _;

    unsafe {
        xTaskCreatePinnedToCore(
            Some(task1),
            "mpu6050_task".as_ptr() as *const i8 as *mut i8,
            4096,
            task_data_ptr,
            5,
            ptr::null_mut(),
            0, // Use core 0
        );
    }

    loop {
        log::info!("Hello From Main");
        FreeRtos::delay_ms(10000);
    }
}
